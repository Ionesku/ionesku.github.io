<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Звездная система возле черной дыры</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000;
        }
        canvas { 
            display: block; 
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            pointer-events: none;
            z-index: 100;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
        button {
            margin: 5px;
            padding: 5px 10px;
            background-color: #444;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        button:hover {
            background-color: #666;
        }
    </style>
</head>
<body>
    <div id="info">Симуляция звездной системы возле черной дыры</div>
    <div id="controls">
        <button id="toggleCamera">Сменить режим камеры</button>
        <button id="toggleAccretionDisk">Вкл/выкл аккреционный диск</button>
        <button id="toggleGravitationalLensing">Вкл/выкл гравитационное линзирование</button>
        <div style="margin-top: 10px;">
            <label for="simulationSpeed" style="color: white; display: block; margin-bottom: 5px;">Скорость симуляции: <span id="speedValue">1.0</span>x</label>
            <input type="range" id="simulationSpeed" min="0.1" max="5" step="0.1" value="1" style="width: 100%;">
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script>
        // Константы
        const G = 6.67430e-11; // Гравитационная постоянная
        const C = 299792458; // Скорость света
        const SCALE = 1e9; // Масштабный коэффициент для визуализации

        // Основные переменные
        let scene, camera, renderer;
        let blackHole, accretionDisk, star, donorStar, planets = [];
        let cameraMode = 'orbit'; // 'orbit' или 'follow'
        let followIndex = 0;
        let showAccretionDisk = true;
        let showGravitationalLensing = true;
        let clock = new THREE.Clock();
        let simulationSpeed = 1.0;
        let particleSystem, particleCount = 10000;
        let noiseGenerator = new SimplexNoise();
        
        // Инициализация
        function init() {
            // Создание сцены
            scene = new THREE.Scene();
            
            // Создание камеры
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
            camera.position.set(0, 50, 100);
            camera.lookAt(0, 0, 0);
            
            // Создание рендерера
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            
            // Добавление звезд на фоне
            createStarfield();
            
            // Создание черной дыры
            createBlackHole();
            
            // Создание аккреционного диска
            createAccretionDisk();
            
            // Создание звезды
            createStar();
            
            // Создание планет
            createPlanets();
			
			// Создание звезды-сверхгиганта
			const supergiant = createSupergiantStar();
            
            // Создание послесвечения
            createPostProcessing();
            
            // Обработчики событий
            window.addEventListener('resize', onWindowResize);
            document.getElementById('toggleCamera').addEventListener('click', toggleCameraMode);
            document.getElementById('toggleAccretionDisk').addEventListener('click', toggleAccretionDisk);
            document.getElementById('toggleGravitationalLensing').addEventListener('click', toggleGravitationalLensing);
            
            // Обработчик изменения скорости симуляции
            const speedSlider = document.getElementById('simulationSpeed');
            const speedValue = document.getElementById('speedValue');
            speedSlider.addEventListener('input', function() {
                simulationSpeed = parseFloat(this.value);
                speedValue.textContent = simulationSpeed.toFixed(1);
            });
            
            // Инициализация информации о камере
            document.getElementById('info').textContent = getCameraInfo();
            
            // Запуск анимации
            animate();
        }
        
        // Создание послесвечения и эффектов
        function createPostProcessing() {
            // В этой версии Three.js мы используем простые решения для визуальных эффектов
            // В полноценном проекте можно было бы использовать шейдеры и EffectComposer
            
            // Добавляем подсветку черной дыры
            const blackHoleLight = new THREE.PointLight(0x0066ff, 0.8, 50);
            blackHoleLight.position.set(0, 0, 0);
            scene.add(blackHoleLight);
            
            // Усиливаем свет от звезды
            const starLight = new THREE.PointLight(0xffffaa, 1.2, 150);
            starLight.position.copy(star.position);
            scene.add(starLight);
            
            // Добавляем рассеянный свет для общего освещения сцены
            const ambientLight = new THREE.AmbientLight(0x111111);
            scene.add(ambientLight);
        }
        
        // Создание звездного поля на фоне
        function createStarfield() {
            // Создаем несколько слоев звезд для эффекта глубины
            createStarLayer(10000, 0.2, 2000); // Дальние звезды
            createStarLayer(5000, 0.4, 1000);  // Средние звезды
            createStarLayer(1000, 0.6, 500);   // Близкие яркие звезды
            
            // Создаем несколько туманностей
            createNebula(1000, 200, 200, 0x4466aa, 0.15);
            createNebula(-800, -300, -500, 0xaa6644, 0.1);
            createNebula(600, -200, -800, 0x66aa77, 0.12);
        }
        
        // Создание слоя звезд
        function createStarLayer(count, size, distance) {
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: size,
                transparent: true,
                opacity: 0.8
            });
            
            const starsVertices = [];
            const starsColors = [];
            
            for (let i = 0; i < count; i++) {
                const x = (Math.random() - 0.5) * distance * 2;
                const y = (Math.random() - 0.5) * distance * 2;
                const z = (Math.random() - 0.5) * distance * 2;
                starsVertices.push(x, y, z);
                
                // Добавляем случайные цвета звезд
                let r, g, b;
                const colorType = Math.random();
                
                if (colorType < 0.6) {
                    // Белые и голубоватые звезды (наиболее распространенные)
                    r = 0.8 + Math.random() * 0.2;
                    g = 0.8 + Math.random() * 0.2;
                    b = 0.9 + Math.random() * 0.1;
                } else if (colorType < 0.8) {
                    // Красноватые звезды
                    r = 0.9 + Math.random() * 0.1;
                    g = 0.6 + Math.random() * 0.3;
                    b = 0.6 + Math.random() * 0.2;
                } else if (colorType < 0.95) {
                    // Желтоватые звезды
                    r = 0.9 + Math.random() * 0.1;
                    g = 0.9 + Math.random() * 0.1;
                    b = 0.5 + Math.random() * 0.3;
                } else {
                    // Редкие голубые гиганты
                    r = 0.5 + Math.random() * 0.3;
                    g = 0.7 + Math.random() * 0.3;
                    b = 0.9 + Math.random() * 0.1;
                }
                
                starsColors.push(r, g, b);
            }
            
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            starsGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starsColors, 3));
            
            starsMaterial.vertexColors = true;
            
            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
        }
        
        // Создание туманности
        function createNebula(x, y, z, color, opacity) {
            // Используем частицы для создания облакоподобной туманности
            const particlesCount = 1000;
            const particlesGeometry = new THREE.BufferGeometry();
            const particlesMaterial = new THREE.PointsMaterial({
                color: color,
                size: 5,
                transparent: true,
                opacity: opacity,
                blending: THREE.AdditiveBlending
            });
            
            const positions = new Float32Array(particlesCount * 3);
            const sizes = new Float32Array(particlesCount);
            
            const nebulaCenterX = x;
            const nebulaCenterY = y;
            const nebulaCenterZ = z;
            const nebulaSize = 300;
            
            for (let i = 0; i < particlesCount; i++) {
                const i3 = i * 3;
                
                // Случайное распределение внутри эллипсоида
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const r = Math.random() * nebulaSize;
                
                positions[i3] = nebulaCenterX + r * Math.sin(phi) * Math.cos(theta);
                positions[i3+1] = nebulaCenterY + r * 0.6 * Math.sin(phi) * Math.sin(theta);
                positions[i3+2] = nebulaCenterZ + r * 0.8 * Math.cos(phi);
                
                sizes[i] = 2 + Math.random() * 4;
            }
            
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particlesGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const particles = new THREE.Points(particlesGeometry, particlesMaterial);
            scene.add(particles);
        }
        
        		// 4. Исправление джетов (синих "штук")
		function createJet() {
			// Создаем более тонкие и элегантные джеты
			
			// Верхний джет
			const jetGeometry1 = new THREE.ConeGeometry(0.5, 30, 16, 1);
			const jetMaterial1 = new THREE.MeshBasicMaterial({
				color: 0x00aaff,
				transparent: true,
				opacity: 0.6,
				side: THREE.DoubleSide,
				blending: THREE.AdditiveBlending
			});
			
			const jet1 = new THREE.Mesh(jetGeometry1, jetMaterial1);
			jet1.position.set(0, 15, 0); // Располагаем выше
			blackHole.add(jet1);
			
			// Добавляем внутренний конус для свечения
			const innerJetGeometry1 = new THREE.ConeGeometry(0.2, 35, 16, 1);
			const innerJetMaterial1 = new THREE.MeshBasicMaterial({
				color: 0x88eeff,
				transparent: true,
				opacity: 0.8,
				side: THREE.DoubleSide,
				blending: THREE.AdditiveBlending
			});
			
			const innerJet1 = new THREE.Mesh(innerJetGeometry1, innerJetMaterial1);
			innerJet1.position.set(0, 0, 0);
			jet1.add(innerJet1);
			
			// Нижний джет
			const jetGeometry2 = new THREE.ConeGeometry(0.5, 30, 16, 1);
			const jetMaterial2 = new THREE.MeshBasicMaterial({
				color: 0x00aaff,
				transparent: true,
				opacity: 0.6,
				side: THREE.DoubleSide,
				blending: THREE.AdditiveBlending
			});
			
			const jet2 = new THREE.Mesh(jetGeometry2, jetMaterial2);
			jet2.position.set(0, -15, 0);
			jet2.rotation.x = Math.PI; // Поворачиваем вниз
			blackHole.add(jet2);
			
			// Добавляем внутренний конус для свечения (нижний)
			const innerJetGeometry2 = new THREE.ConeGeometry(0.2, 35, 16, 1);
			const innerJetMaterial2 = new THREE.MeshBasicMaterial({
				color: 0x88eeff,
				transparent: true,
				opacity: 0.8,
				side: THREE.DoubleSide,
				blending: THREE.AdditiveBlending
			});
			
			const innerJet2 = new THREE.Mesh(innerJetGeometry2, innerJetMaterial2);
			innerJet2.position.set(0, 0, 0);
			jet2.add(innerJet2);
			
			// Добавляем частицы для джета более элегантно
			createImprovedJetParticles(jet1, true);
			createImprovedJetParticles(jet2, false);
		}

		// 8. Создание звезды-сверхгиганта
		function createSupergiantStar() {
			// Создаем текстуру для звезды-сверхгиганта
			const canvas = document.createElement('canvas');
			canvas.width = 1024;
			canvas.height = 1024;
			const context = canvas.getContext('2d');
			
			// Базовый цвет (красноватый для красного сверхгиганта)
			context.fillStyle = '#ff3300';
			context.fillRect(0, 0, canvas.width, canvas.height);
			
			// Добавляем шумовую текстуру для имитации поверхности
			const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
			const data = imageData.data;
			
			for (let y = 0; y < canvas.height; y++) {
				for (let x = 0; x < canvas.width; x++) {
					const i = (y * canvas.width + x) * 4;
					
					// Используем шум Перлина для создания деталей поверхности
					// Для поверхности сверхгиганта характерны большие выпуклости и пятна
					const noise1 = noiseGenerator.noise2D(x / 50, y / 50) * 0.4;
					const noise2 = noiseGenerator.noise2D(x / 20, y / 20) * 0.2;
					const noise = noise1 + noise2;
					
					data[i] = Math.min(255, Math.max(0, data[i] + noise * 60)); // R
					data[i+1] = Math.min(255, Math.max(0, data[i+1] + noise * 30)); // G
					data[i+2] = Math.min(255, Math.max(0, data[i+2] + noise * 15)); // B
				}
			}
			
			// Добавляем крупные конвективные ячейки, характерные для сверхгигантов
			for (let i = 0; i < 30; i++) {
				const cellX = Math.random() * canvas.width;
				const cellY = Math.random() * canvas.height;
				const cellRadius = 50 + Math.random() * 150;
				const brightness = -0.2 + Math.random() * 0.4; // иногда темнее, иногда ярче
				
				for (let y = Math.max(0, cellY - cellRadius); y < Math.min(canvas.height, cellY + cellRadius); y++) {
					for (let x = Math.max(0, cellX - cellRadius); x < Math.min(canvas.width, cellX + cellRadius); x++) {
						const dist = Math.sqrt((x - cellX) ** 2 + (y - cellY) ** 2);
						if (dist < cellRadius) {
							const i = (y * canvas.width + x) * 4;
							const factor = (1 - dist / cellRadius) * brightness;
							
							data[i] = Math.min(255, Math.max(0, data[i] + factor * 50));
							data[i+1] = Math.min(255, Math.max(0, data[i+1] + factor * 30));
							data[i+2] = Math.min(255, Math.max(0, data[i+2] + factor * 10));
						}
					}
				}
			}
			
			context.putImageData(imageData, 0, 0);
			
			// Создаем сверхгиганта - он должен быть значительно больше стандартной звезды
			const supergiantTexture = new THREE.CanvasTexture(canvas);
			const supergiantGeometry = new THREE.SphereGeometry(25, 64, 64); // Большой радиус
			const supergiantMaterial = new THREE.MeshBasicMaterial({
				map: supergiantTexture,
				emissive: 0xff3300,
				emissiveIntensity: 0.5
			});
			
			const supergiant = new THREE.Mesh(supergiantGeometry, supergiantMaterial);
			supergiant.position.set(200, 30, 100); // Расположим его далеко, но в поле зрения
			scene.add(supergiant);
			
			// Добавляем световой эффект
			const supergiantLight = new THREE.PointLight(0xff5533, 2, 300);
			supergiant.add(supergiantLight);
			
			// Создаем атмосферу сверхгиганта
			const atmosphereGeometry = new THREE.SphereGeometry(27, 32, 32);
			const atmosphereMaterial = new THREE.MeshBasicMaterial({
				color: 0xff6644,
				transparent: true,
				opacity: 0.3,
				side: THREE.BackSide
			});
			
			const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
			supergiant.add(atmosphere);
			
			// Параметры звезды
			supergiant.mass = 20e30; // 20 солнечных масс
			supergiant.rotationSpeed = 0.00002; // Медленное вращение
			
			// Добавляем в сцену
			window.supergiant = supergiant;
			
			// Добавляем функцию обновления
			supergiant.update = function(delta) {
				// Медленное вращение
				this.rotation.y += this.rotationSpeed * delta * simulationSpeed;
				
				// Пульсация, характерная для сверхгигантов
				const time = Date.now() * 0.0001;
				const pulseFactor = 1 + Math.sin(time * 0.2) * 0.02;
				this.scale.set(pulseFactor, pulseFactor, pulseFactor);
				
				// Пульсация света
				if (this.children[0] && this.children[0].intensity) {
					this.children[0].intensity = 2 + Math.sin(time * 0.3) * 0.2;
				}
			};
			
			return supergiant;
		}

		// 7. Создание черной дыры в стиле "Интерстеллар" с линзированием
		function createBlackHole() {
			// Создаем сферу для представления горизонта событий
			const blackHoleGeometry = new THREE.SphereGeometry(5, 64, 64);
			const blackHoleMaterial = new THREE.MeshBasicMaterial({ 
				color: 0x000000,
				transparent: false,
				opacity: 1
			});
			
			blackHole = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
			scene.add(blackHole);
			
			// Добавляем искажение пространства вокруг черной дыры (симуляция линзирования)
			const lensGeometry = new THREE.SphereGeometry(10, 64, 64);
			const lensMaterial = new THREE.MeshBasicMaterial({
				color: 0x000000,
				transparent: true,
				opacity: 0.5,
				side: THREE.FrontSide
			});
			
			const lens = new THREE.Mesh(lensGeometry, lensMaterial);
			blackHole.add(lens);
			
			// Добавляем яркое свечение вокруг (симуляция фотонного кольца)
			const photonRingGeometry = new THREE.RingGeometry(5, 5.5, 64, 1);
			const photonRingMaterial = new THREE.MeshBasicMaterial({
				color: 0xffffff,
				transparent: true,
				opacity: 0.8,
				side: THREE.DoubleSide,
				blending: THREE.AdditiveBlending
			});
			
			const photonRing = new THREE.Mesh(photonRingGeometry, photonRingMaterial);
			photonRing.rotation.x = Math.PI / 2;
			blackHole.add(photonRing);
			
			// Параметры черной дыры
			blackHole.mass = 1e30; // Масса в кг
			blackHole.schwarzschildRadius = (2 * G * blackHole.mass) / (C * C);
			
			const jets = createRelativisticJets();
            blackHole.jets = jets;
		}
        
		function createImprovedJetParticles(jet, isUp) {
			const particlesGeometry = new THREE.BufferGeometry();
			const particlesMaterial = new THREE.PointsMaterial({
				color: new THREE.Color(0x99ddff),
				size: 0.15,
				transparent: true,
				opacity: 0.8,
				blending: THREE.AdditiveBlending,
				depthWrite: false,
				map: createImprovedParticleTexture()
			});
			
			const particlesCount = 800; // Больше частиц для лучшего эффекта
			const particlesPositions = new Float32Array(particlesCount * 3);
			const particlesVelocities = new Float32Array(particlesCount * 3);
			const particlesLifetimes = new Float32Array(particlesCount);
			const particlesSizes = new Float32Array(particlesCount);
			
			// Инициализация частиц
			for (let i = 0; i < particlesCount; i++) {
				const i3 = i * 3;
				
				// Создаем более узкую струю частиц
				const distance = Math.random() * 30; // Расстояние вдоль джета
				const angle = Math.random() * Math.PI * 2;
				const radius = Math.pow(Math.random(), 2) * 0.3 * (1 + distance / 30); // Конусообразное распределение
				
				particlesPositions[i3] = Math.cos(angle) * radius;
				particlesPositions[i3+1] = isUp ? distance : -distance;
				particlesPositions[i3+2] = Math.sin(angle) * radius;
				
				// Скорость - наружу и вверх/вниз с небольшим разбросом
				const speed = 0.05 + Math.random() * 0.15 * (1 + distance / 20);
				const directionY = isUp ? 1 : -1;
				const spreadFactor = 0.01 * (distance / 30);
				
				particlesVelocities[i3] = (Math.random() - 0.5) * spreadFactor;
				particlesVelocities[i3+1] = directionY * speed;
				particlesVelocities[i3+2] = (Math.random() - 0.5) * spreadFactor;
				
				// Время жизни и размер зависит от расстояния
				particlesLifetimes[i] = Math.random() * 0.8;
				particlesSizes[i] = 0.1 + Math.random() * 0.1 * (1 + distance / 30);
			}
			
			particlesGeometry.setAttribute('position', new THREE.BufferAttribute(particlesPositions, 3));
			particlesGeometry.setAttribute('size', new THREE.BufferAttribute(particlesSizes, 1));
			
			const particles = new THREE.Points(particlesGeometry, particlesMaterial);
			particles.userData.velocities = particlesVelocities;
			particles.userData.lifetimes = particlesLifetimes;
			particles.userData.sizes = particlesSizes;
			particles.userData.isUp = isUp;
			
			jet.add(particles);
			jet.particles = particles;
		}

		function updateJetParticles(delta) {
            // Перебираем все джеты черной дыры
            if (!blackHole || !blackHole.children) return;
            
            blackHole.children.forEach(child => {
                if (child.particles) {
                    const particles = child.particles;
                    const positions = particles.geometry.attributes.position.array;
                    const velocities = particles.userData.velocities;
                    const lifetimes = particles.userData.lifetimes;
                    const isUp = particles.userData.isUp;
                    
                    for (let i = 0; i < lifetimes.length; i++) {
                        const i3 = i * 3;
                        
                        // Увеличиваем время жизни
                        lifetimes[i] += 0.01 * delta * simulationSpeed;
                        
                        // Обновляем позицию
                        positions[i3] += velocities[i3] * delta * simulationSpeed;
                        positions[i3+1] += velocities[i3+1] * delta * simulationSpeed;
                        positions[i3+2] += velocities[i3+2] * delta * simulationSpeed;
                        
                        // Если частица вышла за пределы или время жизни истекло, пересоздаем
                        if (lifetimes[i] >= 1.0 || 
                            (isUp && positions[i3+1] > 100) || 
                            (!isUp && positions[i3+1] < -100)) {
                            
                            // Создаем новую частицу у основания джета
                            const angle = Math.random() * Math.PI * 2;
                            const radius = Math.random() * 0.5;
                            
                            positions[i3] = Math.cos(angle) * radius;
                            positions[i3+1] = isUp ? 0 : 0;
                            positions[i3+2] = Math.sin(angle) * radius;
                            
                            // Обновляем скорость
                            const speed = 1 + Math.random() * 5;
                            velocities[i3] = (Math.random() - 0.5) * 0.1;
                            velocities[i3+1] = isUp ? speed : -speed;
                            velocities[i3+2] = (Math.random() - 0.5) * 0.1;
                            
                            // Сбрасываем время жизни
                            lifetimes[i] = 0;
                        }
                    }
                    
                    particles.geometry.attributes.position.needsUpdate = true;
                }
            });
        }

        

        // 6. Создаем геометрию пути потока вещества
        function createStreamPathGeometry(startPoint, endPoint) {
            // Создаем путь с изгибом под действием гравитации
            const curvePoints = [];
            const segments = 50;
            
            // Вычисляем направление от звезды-донора к черной дыре
            const direction = new THREE.Vector3().subVectors(endPoint, startPoint).normalize();
            
            // Вычисляем перпендикулярное направление в плоскости XZ
            const perpDirection = new THREE.Vector3(-direction.z, 0, direction.x).normalize();
            
            // Расстояние между точками
            const distance = startPoint.distanceTo(endPoint);
            
            // Создаем точки кривой с изгибом
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                
                // Позиция вдоль прямой линии
                const pos = new THREE.Vector3().lerpVectors(startPoint, endPoint, t);
                
                // Добавляем изгиб, максимальный в середине пути
                const bendFactor = Math.sin(t * Math.PI) * distance * 0.05;
                pos.add(perpDirection.clone().multiplyScalar(bendFactor));
                
                // Добавляем гравитационное искривление по мере приближения к черной дыре
                if (t > 0.5) {
                    const gravityPull = Math.pow((t - 0.5) * 2, 2) * distance * 0.1;
                    pos.add(direction.clone().multiplyScalar(-gravityPull));
                }
                
                curvePoints.push(pos);
            }
            
            // Создаем кривую по точкам
            const curve = new THREE.CatmullRomCurve3(curvePoints);
            
            // Создаем геометрию трубы вокруг кривой
            const tubeGeometry = new THREE.TubeGeometry(curve, segments, 1.5, 8, false);
            
            return tubeGeometry;
        }

        // Создание потока вещества от звезды-донора к черной дыре
        function createMatterStream() {
            const streamGeometry = new THREE.BufferGeometry();
            
            // Используем улучшенную текстуру для частиц потока
            const particleTexture = createImprovedParticleTexture();
            
            const streamMaterial = new THREE.PointsMaterial({
                color: 0xffddaa,
                size: 0.6, // Увеличиваем размер частиц
                transparent: true,
                opacity: 0.9, // Увеличиваем непрозрачность
                blending: THREE.AdditiveBlending,
                map: particleTexture, // Используем текстуру с мягкими краями
                depthWrite: false
            });
            
            const particleCount = 5000; // Увеличиваем количество частиц
            const positions = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            const lifetimes = new Float32Array(particleCount);
            const sizes = new Float32Array(particleCount); // Добавляем разные размеры
            
            // Инициализация частиц
            for (let i = 0; i < particleCount; i++) {
                // Не показываем все частицы сразу, распределяем их жизненный цикл
                lifetimes[i] = Math.random();
                
                // Различные размеры частиц для объемности
                sizes[i] = 0.3 + Math.random() * 0.8;
                
                // Начальная позиция - возле звезды-донора
                updateStreamParticle(i, positions, velocities, lifetimes, true);
            }
            
            streamGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            streamGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const streamParticles = new THREE.Points(streamGeometry, streamMaterial);
            streamParticles.userData.velocities = velocities;
            streamParticles.userData.lifetimes = lifetimes;
            streamParticles.userData.sizes = sizes;
            scene.add(streamParticles);
            
            // Добавляем свечение вдоль потока
            const pathGeometry = createStreamPathGeometry(donorStar.position, blackHole.position);
            const pathMaterial = new THREE.MeshBasicMaterial({
                color: 0xffaa66,
                transparent: true,
                opacity: 0.2,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide
            });
            
            const streamPath = new THREE.Mesh(pathGeometry, pathMaterial);
            scene.add(streamPath);
            
            donorStar.streamParticles = streamParticles;
            donorStar.streamPath = streamPath; // Сохраняем ссылку на путь потока
        }
        
        // Обновление частицы в потоке вещества
        function updateStreamParticle(index, positions, velocities, lifetimes, isInit = false) {
            const i3 = index * 3;
            
            if (isInit || lifetimes[index] >= 1.0) {
                // Создаем новую частицу возле звезды-донора с более широким разбросом
                const offset = new THREE.Vector3(
                    (Math.random() - 0.5) * donorStar.geometry.parameters.radius * 1.2,
                    (Math.random() - 0.5) * donorStar.geometry.parameters.radius * 1.2,
                    (Math.random() - 0.5) * donorStar.geometry.parameters.radius * 1.2
                );
                
                positions[i3] = donorStar.position.x + offset.x;
                positions[i3+1] = donorStar.position.y + offset.y;
                positions[i3+2] = donorStar.position.z + offset.z;
                
                // Более реалистичное направление к черной дыре с изгибом траектории
                // Базовое направление к черной дыре
                const direction = new THREE.Vector3(
                    blackHole.position.x - positions[i3],
                    blackHole.position.y - positions[i3+1],
                    blackHole.position.z - positions[i3+2]
                ).normalize();
                
                // Добавляем компонент перпендикулярный направлению для создания спирального движения
                const perpComponent = new THREE.Vector3(-direction.z, 0, direction.x).normalize();
                const perpFactor = (Math.random() - 0.5) * 0.3; // Случайное отклонение
                
                // Итоговое направление
                direction.add(perpComponent.multiplyScalar(perpFactor)).normalize();
                
                const speed = 0.2 + Math.random() * 0.4; // Более широкий диапазон скоростей
                velocities[i3] = direction.x * speed;
                velocities[i3+1] = direction.y * speed;
                velocities[i3+2] = direction.z * speed;
                
                lifetimes[index] = 0;
            }
        }
                

        // 2. Увеличение яркости аккреционного диска
        function createAccretionDisk() {
            // Создаем группу для аккреционного диска
            const diskGroup = new THREE.Group();
            
            // Создаем основной тонкий диск (как в фильме "Интерстеллар")
            const diskGeometry = new THREE.RingGeometry(8, 40, 128, 2);
            
            // Создаем canvas для текстуры
            const canvas = document.createElement('canvas');
            canvas.width = 2048; // Увеличиваем разрешение для лучшего качества
            canvas.height = 2;
            const context = canvas.getContext('2d');
            
            // Создаем градиент в стиле "Интерстеллар" с увеличенной яркостью
            const gradient = context.createLinearGradient(0, 0, canvas.width, 0);
            gradient.addColorStop(0, '#ffffff'); // Яркий белый в центре
            gradient.addColorStop(0.1, '#ffffff');
            gradient.addColorStop(0.2, '#ffffcc');
            gradient.addColorStop(0.4, '#ffdd88');
            gradient.addColorStop(0.6, '#ffbb66');
            gradient.addColorStop(0.8, '#dd8844');
            gradient.addColorStop(1, '#884422');
            
            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            
            const diskMaterial = new THREE.MeshBasicMaterial({
                map: texture,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 1.0, // Увеличиваем непрозрачность
                blending: THREE.AdditiveBlending
            });
            
            const diskRing = new THREE.Mesh(diskGeometry, diskMaterial);
            diskRing.rotation.x = Math.PI / 2;
            diskGroup.add(diskRing);
            
            // Добавляем второй внутренний яркий диск
            const innerDiskGeometry = new THREE.RingGeometry(6, 12, 128, 2);
            
            const innerCanvas = document.createElement('canvas');
            innerCanvas.width = 2048;
            innerCanvas.height = 2;
            const innerContext = innerCanvas.getContext('2d');
            
            const innerGradient = innerContext.createLinearGradient(0, 0, innerCanvas.width, 0);
            innerGradient.addColorStop(0, '#ffffff');
            innerGradient.addColorStop(0.7, '#ffffff');
            innerGradient.addColorStop(1, '#ffffee');
            
            innerContext.fillStyle = innerGradient;
            innerContext.fillRect(0, 0, innerCanvas.width, innerCanvas.height);
            
            const innerTexture = new THREE.Texture(innerCanvas);
            innerTexture.needsUpdate = true;
            
            const innerDiskMaterial = new THREE.MeshBasicMaterial({
                map: innerTexture,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 1.0, // Максимальная непрозрачность
                blending: THREE.AdditiveBlending
            });
            
            const innerDiskRing = new THREE.Mesh(innerDiskGeometry, innerDiskMaterial);
            innerDiskRing.rotation.x = Math.PI / 2;
            diskGroup.add(innerDiskRing);
            
            // Добавляем третий, очень яркий внутренний диск для усиления эффекта
            const brightInnerDiskGeometry = new THREE.RingGeometry(5.5, 8, 128, 2);
            
            const brightDiskMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending
            });
            
            const brightInnerDiskRing = new THREE.Mesh(brightInnerDiskGeometry, brightDiskMaterial);
            brightInnerDiskRing.rotation.x = Math.PI / 2;
            diskGroup.add(brightInnerDiskRing);
            
            // Создаем эффект свечения вокруг черной дыры (увеличиваем интенсивность)
            const glowGeometry = new THREE.SphereGeometry(7, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.3, // Увеличиваем яркость свечения
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending
            });
            
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            diskGroup.add(glow);
            
            // Добавляем световые эффекты для усиления яркости диска
            const diskLight = new THREE.PointLight(0xffffcc, 2, 50);
            diskLight.position.set(0, 0, 0);
            diskGroup.add(diskLight);
            
            accretionDisk = diskGroup;
            scene.add(accretionDisk);
            
            // Добавляем частицы для более реалистичного эффекта
            createInterstellarAccretionParticles();
        }

        function createJetParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            
            context.clearRect(0, 0, canvas.width, canvas.height);
            
            // Градиент для частиц джета (голубоватый)
            const gradient = context.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, canvas.width / 2
            );
            
            gradient.addColorStop(0, 'rgba(150, 230, 255, 1.0)');
            gradient.addColorStop(0.3, 'rgba(100, 200, 255, 0.8)');
            gradient.addColorStop(0.7, 'rgba(50, 150, 255, 0.3)');
            gradient.addColorStop(1, 'rgba(0, 100, 255, 0)');
            
            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // 12. Создание частиц для джетов
        function createJetParticles(jet, isUp) {
            const particlesGeometry = new THREE.BufferGeometry();
            
            // Создаем текстуру для частиц джета (голубоватые)
            const jetParticleTexture = createJetParticleTexture();
            
            const particlesMaterial = new THREE.PointsMaterial({
                size: 0.4,
                map: jetParticleTexture,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const particleCount = 1000;
            const positions = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            const lifetimes = new Float32Array(particleCount);
            
            // Инициализируем частицы
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // Распределяем начальные позиции частиц в цилиндре
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 0.5;
                const height = Math.random() * 70;
                
                positions[i3] = Math.cos(angle) * radius;
                positions[i3+1] = isUp ? height : -height;
                positions[i3+2] = Math.sin(angle) * radius;
                
                // Скорость - преимущественно вверх/вниз с небольшим разбросом
                const speed = 1 + Math.random() * 5;
                velocities[i3] = (Math.random() - 0.5) * 0.1;
                velocities[i3+1] = isUp ? speed : -speed;
                velocities[i3+2] = (Math.random() - 0.5) * 0.1;
                
                // Случайное время жизни
                lifetimes[i] = Math.random();
            }
            
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particles = new THREE.Points(particlesGeometry, particlesMaterial);
            particles.userData.velocities = velocities;
            particles.userData.lifetimes = lifetimes;
            particles.userData.isUp = isUp;
            
            jet.add(particles);
            jet.particles = particles;
            
            return particles;
        }


        function createRelativisticJets() {
            // Создаем геометрию для джетов
            const jetLength = 100;
            const jetGeometry = new THREE.CylinderGeometry(0, 3, jetLength, 32, 1, true);
            
            // Материал для джета с градиентом
            const jetCanvas = document.createElement('canvas');
            jetCanvas.width = 256;
            jetCanvas.height = 1;
            const jetContext = jetCanvas.getContext('2d');
            
            // Создаем градиент от синего к прозрачному
            const jetGradient = jetContext.createLinearGradient(0, 0, jetCanvas.width, 0);
            jetGradient.addColorStop(0, 'rgba(100, 200, 255, 1.0)');
            jetGradient.addColorStop(0.5, 'rgba(80, 160, 255, 0.7)');
            jetGradient.addColorStop(1, 'rgba(50, 100, 255, 0.0)');
            
            jetContext.fillStyle = jetGradient;
            jetContext.fillRect(0, 0, jetCanvas.width, jetCanvas.height);
            
            const jetTexture = new THREE.CanvasTexture(jetCanvas);
            jetTexture.needsUpdate = true;
            
            const jetMaterial = new THREE.MeshBasicMaterial({
                map: jetTexture,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide
            });
            
            // Верхний джет
            const topJet = new THREE.Mesh(jetGeometry, jetMaterial);
            topJet.position.set(0, jetLength / 2, 0);
            topJet.rotation.x = Math.PI;
            blackHole.add(topJet);
            
            // Нижний джет
            const bottomJet = new THREE.Mesh(jetGeometry, jetMaterial);
            bottomJet.position.set(0, -jetLength / 2, 0);
            blackHole.add(bottomJet);
            
            // Добавляем частицы для джетов
            createJetParticles(topJet, true);
            createJetParticles(bottomJet, false);
            
            // Добавляем световые эффекты
            const topLight = new THREE.PointLight(0x4488ff, 1, 50);
            topLight.position.set(0, 10, 0);
            topJet.add(topLight);
            
            const bottomLight = new THREE.PointLight(0x4488ff, 1, 50);
            bottomLight.position.set(0, -10, 0);
            bottomJet.add(bottomLight);
            
            return [topJet, bottomJet];
        }
		
        // 3. Улучшение функции для создания частиц аккреционного диска (больше и ярче)
        function createInterstellarAccretionParticles() {
            const particlesGeometry = new THREE.BufferGeometry();
            
            // Создаем текстуру частицы
            const particleTexture = createImprovedParticleTexture();
            
            const particlesMaterial = new THREE.PointsMaterial({
                size: 0.6, // Увеличиваем размер частиц
                map: particleTexture,
                transparent: true,
                opacity: 0.9, // Увеличиваем непрозрачность для большей яркости
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const particleCount = 30000; // Увеличиваем количество частиц
            const particlesVertices = [];
            const particlesVelocities = [];
            const particlesColors = [];
            const particlesLifetimes = []; // Добавляем массив времени жизни
            
            for (let i = 0; i < particleCount; i++) {
                // Распределяем частицы в тонком плоском диске
                let radius, angle, height;
                
                // 70% частиц концентрируем в основном диске
                if (i < particleCount * 0.7) {
                    radius = 8 + Math.pow(Math.random(), 0.5) * 32;
                    angle = Math.random() * Math.PI * 2;
                    // Очень тонкий диск, как в фильме
                    height = (Math.random() - 0.5) * 0.3;
                } else {
                    // 30% частиц размещаем в более широкой области для создания размытия
                    radius = 8 + Math.random() * 32;
                    angle = Math.random() * Math.PI * 2;
                    // Более широкое распределение
                    height = (Math.random() - 0.5) * 2;
                }
                
                const x = radius * Math.cos(angle);
                const y = height;
                const z = radius * Math.sin(angle);
                
                particlesVertices.push(x, y, z);
                
                // Скорость - кеплеровская орбита
                const speed = Math.sqrt(G * blackHole.mass / radius) / 8e5;
                const vx = -speed * Math.sin(angle);
                const vz = speed * Math.cos(angle);
                particlesVelocities.push(vx, 0, vz);
                
                // Добавляем время жизни
                particlesLifetimes.push(Math.random());
                
                // Цвет в зависимости от расстояния - как у диска из "Интерстеллар", но ярче
                let r, g, b;
                
                if (radius < 12) {
                    // Яркий белый/голубоватый ближе к горизонту событий
                    r = 1.0;
                    g = 1.0;
                    b = 1.0;
                } else if (radius < 20) {
                    // Бело-желтый в средней части
                    r = 1.0;
                    g = 1.0;
                    b = 0.9 - (radius - 12) / 16 * 0.5;
                } else {
                    // Янтарно-коричневый ближе к внешнему краю
                    r = 1.0;
                    g = 0.9 - (radius - 20) / 20 * 0.4;
                    b = 0.4 - (radius - 20) / 20 * 0.3;
                }
                
                particlesColors.push(r, g, b);
            }
            
            particlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particlesVertices, 3));
            particlesGeometry.setAttribute('color', new THREE.Float32BufferAttribute(particlesColors, 3));
            
            const particles = new THREE.Points(particlesGeometry, particlesMaterial);
            particles.userData.velocities = particlesVelocities;
            particles.userData.originalPositions = [...particlesVertices];
            particles.userData.lifetimes = particlesLifetimes;
            
            scene.add(particles);
            accretionDisk.particles = particles;
        }
                
        // 5. Создание улучшенной текстуры частиц
        function createImprovedParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; // Увеличиваем размер для большей детализации
            canvas.height = 128;
            const context = canvas.getContext('2d');
            
            // Чистый холст
            context.clearRect(0, 0, canvas.width, canvas.height);
            
            // Более яркий градиент для частицы с более плавными переходами
            const gradient = context.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, canvas.width / 2
            );
            
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
            gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.9)'); // Увеличиваем непрозрачность
            gradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.5)'); // Увеличиваем непрозрачность
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }


		// 6. Обновление частиц аккреционного диска
		function updateAccretionDiskParticles(delta) {
			if (!showAccretionDisk || !accretionDisk.particles) return;
			
			const particles = accretionDisk.particles;
			const positions = particles.geometry.attributes.position.array;
			const velocities = particles.userData.velocities;
			
			    // Проверяем наличие lifetimes и инициализируем при необходимости
			if (!particles.userData.lifetimes) {
				particles.userData.lifetimes = Array(positions.length / 3).fill(0).map(() => Math.random());
			}
			const lifetimes = particles.userData.lifetimes;
			
			// Проверяем наличие originalPositions и инициализируем при необходимости
			if (!particles.userData.originalPositions) {
				particles.userData.originalPositions = [...positions];
			}
			const originalPositions = particles.userData.originalPositions;
			
			for (let i = 0; i < positions.length; i += 3) {
			
			     const i3 = i * 3;
        
				// Обновляем время жизни частицы
				lifetimes[i] += 0.001 * delta * simulationSpeed;
				if (lifetimes[i] > 1) lifetimes[i] = 0;
				// Обновление позиций частиц с учетом скорости симуляции
				positions[i] += velocities[i/3*3] * delta * simulationSpeed * 10;
				positions[i+2] += velocities[i/3*3+2] * delta * simulationSpeed * 10;
				
				// Расчет расстояния до черной дыры
				const x = positions[i];
				const y = positions[i+1];
				const z = positions[i+2];
				const distance = Math.sqrt(x*x + z*z);
				
				// Если частица слишком близко к черной дыре, перемещаем её на внешний край
				if (distance < 6) {
					const angle = Math.atan2(z, x);
					positions[i] = 40 * Math.cos(angle);
					positions[i+2] = 40 * Math.sin(angle);
					
					// Пересчитываем скорость
					const radius = 40;
					const speed = Math.sqrt(G * blackHole.mass / radius) / 8e5;
					velocities[i/3*3] = -speed * Math.sin(angle);
					velocities[i/3*3+2] = speed * Math.cos(angle);
				}
				
				// Если частица ушла слишком далеко, тоже возвращаем
				if (distance > 45) {
					const angle = Math.atan2(z, x);
					positions[i] = 8 * Math.cos(angle);
					positions[i+2] = 8 * Math.sin(angle);
					
					// Пересчитываем скорость
					const radius = 8;
					const speed = Math.sqrt(G * blackHole.mass / radius) / 8e5;
					velocities[i/3*3] = -speed * Math.sin(angle);
					velocities[i/3*3+2] = speed * Math.cos(angle);
				}
				
				// Сохраняем тонкий диск - возвращаем Y к нулю с определенной вероятностью
				if (Math.random() < 0.01 * delta * simulationSpeed) {
					positions[i+1] *= 0.9;
				}
			}
			
			particles.geometry.attributes.position.needsUpdate = true;
		}

        
        // Создание текстуры звезды с шумом Перлина
        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const context = canvas.getContext('2d');
            
            // Заполняем базовым цветом
            context.fillStyle = '#ffaa00';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Добавляем шум Перлина
            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const i = (y * canvas.width + x) * 4;
                    
                    // Генерируем шум Перлина с разными частотами
                    const noise1 = noiseGenerator.noise2D(x / 30, y / 30) * 0.5;
                    const noise2 = noiseGenerator.noise2D(x / 10, y / 10) * 0.25;
                    const noise = (noise1 + noise2) * 0.75 + 0.5;
                    
                    // Создаем вариации цвета звезды
                    data[i] = 255; // R
                    data[i+1] = Math.min(255, 170 + noise * 70); // G
                    data[i+2] = Math.max(0, noise * 50); // B
                }
            }
            
            // Добавляем вспышки и пятна на поверхности
            for (let i = 0; i < 10; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 20 + Math.random() * 30;
                const intensity = 0.5 + Math.random() * 0.5;
                
                for (let py = Math.max(0, y - radius); py < Math.min(canvas.height, y + radius); py++) {
                    for (let px = Math.max(0, x - radius); px < Math.min(canvas.width, x + radius); px++) {
                        const dist = Math.sqrt((px - x) ** 2 + (py - y) ** 2);
                        if (dist < radius) {
                            const i = (py * canvas.width + px) * 4;
                            const factor = (1 - dist / radius) * intensity;
                            
                            data[i] = Math.min(255, data[i] + factor * 50);
                            data[i+1] = Math.min(255, data[i+1] + factor * 30);
                        }
                    }
                }
            }
            
            context.putImageData(imageData, 0, 0);
            
            // Создаем текстуру из canvas
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }
        
        // Создание звезды
        function createStar() {
            const starGeometry = new THREE.SphereGeometry(6, 64, 64);
            const starTexture = createStarTexture();
            
            const starMaterial = new THREE.MeshBasicMaterial({ 
                map: starTexture,
                emissive: 0xffaa00,
                emissiveIntensity: 0.5
            });
            
            star = new THREE.Mesh(starGeometry, starMaterial);
            star.position.set(60, 0, 0);
            scene.add(star);
            
            // Параметры звезды
            star.mass = 2e30; // Масса в кг
            star.velocity = new THREE.Vector3(0, 0, Math.sqrt(G * blackHole.mass / 60) / 1e6);
            
            // Добавим свечение
            const starLight = new THREE.PointLight(0xffffaa, 1.5, 150);
            star.add(starLight);
            
            // Добавим корону вокруг звезды
            const coronaGeometry = new THREE.SphereGeometry(7, 32, 32);
            const coronaMaterial = new THREE.MeshBasicMaterial({
                color: 0xffdd44,
                transparent: true,
                opacity: 0.3,
                side: THREE.BackSide
            });
            
            const corona = new THREE.Mesh(coronaGeometry, coronaMaterial);
            star.add(corona);
            
            // Создаем звезду-донор, которая "питает" аккреционный диск
            createDonorStar();
        }
        
        // Создание звезды-донора для аккреционного диска
        function createDonorStar() {
            const donorGeometry = new THREE.SphereGeometry(4, 32, 32);
            const donorTexture = createStarTexture();
            
            const donorMaterial = new THREE.MeshBasicMaterial({ 
                map: donorTexture,
                color: 0xffccaa
            });
            
            donorStar = new THREE.Mesh(donorGeometry, donorMaterial);
            donorStar.position.set(-30, 0, 10);
            scene.add(donorStar);
            
            // Параметры звезды-донора
            donorStar.mass = 0.8e30; // Масса в кг
            donorStar.velocity = new THREE.Vector3(0, 0, -Math.sqrt(G * blackHole.mass / 30) / 1e6);
            
            // Добавим свечение
            const donorLight = new THREE.PointLight(0xffccaa, 0.8, 100);
            donorStar.add(donorLight);
            
            // Создаем поток вещества от звезды-донора к черной дыре
            createMatterStream();
        }
        
        // Создание планет с текстурами
        function createPlanets() {
            // Разнообразные цвета и размеры планет
            const planetColors = [
                { base: 0x3366ff, spots: 0x1133cc }, // Синяя водная планета
                { base: 0x66cc99, spots: 0x338855 }, // Зеленая растительная планета
                { base: 0xaa9977, spots: 0x776655 }, // Коричневая пустынная планета
                { base: 0xcc6644, spots: 0x994422 }, // Красная планета типа Марса
                { base: 0x999999, spots: 0x666666 }  // Серая скалистая планета
            ];
            const planetSizes = [1.5, 2.2, 1.8, 2.5, 1.2];
            
            for (let i = 0; i < 5; i++) {
                // Создаем текстуру для планеты с шумом Перлина
                const planetTexture = createPlanetTexture(planetColors[i].base, planetColors[i].spots);
                
                const planetGeometry = new THREE.SphereGeometry(planetSizes[i], 32, 32);
                const planetMaterial = new THREE.MeshBasicMaterial({ 
                    map: planetTexture,
                    // Для газовых гигантов добавляем свечение
                    emissive: i === 1 || i === 3 ? planetColors[i].base : 0x000000,
                    emissiveIntensity: 0.1
                });
                
                const planet = new THREE.Mesh(planetGeometry, planetMaterial);
                
                // Расположим планеты на расстоянии от звезды с некоторым наклоном
                const distance = 10 + (i * 8);
                const angle = Math.random() * Math.PI * 2;
                const incline = (Math.random() - 0.5) * 0.2; // Небольшой наклон орбиты
                
                const px = 60 + distance * Math.cos(angle);
                const py = distance * Math.sin(incline);
                const pz = distance * Math.sin(angle);
                
                planet.position.set(px, py, pz);
                scene.add(planet);
                
                // Наклон оси планеты
                planet.rotation.x = Math.random() * 0.5;
                
                // Добавляем кольца для некоторых планет
                if (i === 1 || i === 4) {
                    const ringGeometry = new THREE.RingGeometry(planetSizes[i] * 1.5, planetSizes[i] * 2.5, 32, 4);
                    const ringMaterial = new THREE.MeshBasicMaterial({ 
                        color: planetColors[i].spots,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.7
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.PI / 2;
                    ring.rotation.y = Math.random() * 0.5;
                    planet.add(ring);
                }
                
                // Параметры планеты
                planet.mass = 1e24 + Math.random() * 9e24; // Масса в кг
                planet.orbitRadius = distance;
                planet.orbitSpeed = Math.sqrt(G * star.mass / distance) / 1e6;
                planet.orbitAngle = angle;
                planet.orbitInclination = incline;
                planet.orbitCenter = star;
                planet.rotationSpeed = (Math.random() * 0.02 + 0.01); // Скорость вращения вокруг оси
                
                planets.push(planet);
            }
            
            // Добавляем несколько спутников для некоторых планет
            addMoons();
        }
        
        // Создание текстуры планеты с шумом Перлина
        function createPlanetTexture(baseColor, spotColor) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const context = canvas.getContext('2d');
            
            // Конвертируем hex в rgb
            const baseRGB = {
                r: (baseColor >> 16) & 255,
                g: (baseColor >> 8) & 255,
                b: baseColor & 255
            };
            
            const spotRGB = {
                r: (spotColor >> 16) & 255,
                g: (spotColor >> 8) & 255,
                b: spotColor & 255
            };
            
            // Заполняем базовым цветом
            context.fillStyle = `rgb(${baseRGB.r}, ${baseRGB.g}, ${baseRGB.b})`;
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Получаем данные изображения
            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Используем новый генератор шума для этой планеты
            const planetNoise = new SimplexNoise(Math.random() * 1000);
            
            // Добавляем шум Перлина
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const i = (y * canvas.width + x) * 4;
                    
                    // Преобразуем координаты в сферические для более реалистичной карты планеты
                    const nx = x / canvas.width - 0.5;
                    const ny = y / canvas.height - 0.5;
                    const r = Math.sqrt(nx*nx + ny*ny);
                    
                    // Центральная часть - базовый цвет, края - переход к spotColor
                    let noise;
                    
                    if (r < 0.5) {
                        // Несколько слоев шума с разными частотами
                        noise = 
                            planetNoise.noise2D(x / 20, y / 20) * 0.5 +
                            planetNoise.noise2D(x / 10, y / 10) * 0.3 +
                            planetNoise.noise2D(x / 5, y / 5) * 0.2;
                        
                        // Нормализуем к диапазону [0, 1]
                        noise = (noise + 1) / 2;
                        
                        // Интерполируем между базовым цветом и цветом пятен
                        data[i] = Math.floor(baseRGB.r * (1 - noise) + spotRGB.r * noise);
                        data[i+1] = Math.floor(baseRGB.g * (1 - noise) + spotRGB.g * noise);
                        data[i+2] = Math.floor(baseRGB.b * (1 - noise) + spotRGB.b * noise);
                    } else {
                        // Затемнение по краям для эффекта сферы
                        const edgeDarkening = Math.pow((0.5 - r) * 2, 0.5);
                        data[i] = Math.floor(baseRGB.r * edgeDarkening);
                        data[i+1] = Math.floor(baseRGB.g * edgeDarkening);
                        data[i+2] = Math.floor(baseRGB.b * edgeDarkening);
                    }
                }
            }
            
            // Применяем изменения
            context.putImageData(imageData, 0, 0);
            
            // Создаем текстуру
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }
        
        // Добавление спутников к планетам
        function addMoons() {
            // Добавляем луны только для 2-й и 4-й планеты
            [1, 3].forEach(planetIndex => {
                const planet = planets[planetIndex];
                const numMoons = planetIndex === 1 ? 2 : 3;
                
                for (let i = 0; i < numMoons; i++) {
                    const moonSize = 0.3 + Math.random() * 0.3;
                    const moonGeometry = new THREE.SphereGeometry(moonSize, 16, 16);
                    
                    // Создаем простую текстуру для луны
                    const moonCanvas = document.createElement('canvas');
                    moonCanvas.width = 128;
                    moonCanvas.height = 128;
                    const moonCtx = moonCanvas.getContext('2d');
                    
                    // Базовый цвет спутника
                    moonCtx.fillStyle = '#aaaaaa';
                    moonCtx.fillRect(0, 0, moonCanvas.width, moonCanvas.height);
                    
                    // Добавляем кратеры
                    for (let j = 0; j < 20; j++) {
                        const craterX = Math.random() * moonCanvas.width;
                        const craterY = Math.random() * moonCanvas.height;
                        const craterSize = 2 + Math.random() * 8;
                        
                        moonCtx.fillStyle = `rgba(60, 60, 60, ${Math.random() * 0.5 + 0.3})`;
                        moonCtx.beginPath();
                        moonCtx.arc(craterX, craterY, craterSize, 0, Math.PI * 2);
                        moonCtx.fill();
                    }
                    
                    const moonTexture = new THREE.CanvasTexture(moonCanvas);
                    const moonMaterial = new THREE.MeshBasicMaterial({ map: moonTexture });
                    
                    const moon = new THREE.Mesh(moonGeometry, moonMaterial);
                    
                    // Расположение луны относительно планеты
                    const moonDistance = planet.geometry.parameters.radius * (2 + i * 0.8);
                    const moonAngle = Math.random() * Math.PI * 2;
                    const moonInclination = (Math.random() - 0.5) * 0.5;
                    
                    moon.position.set(
                        moonDistance * Math.cos(moonAngle),
                        moonDistance * Math.sin(moonInclination),
                        moonDistance * Math.sin(moonAngle)
                    );
                    
                    // Добавляем луну как ребенка планеты, чтобы она двигалась вместе с планетой
                    planet.add(moon);
                    
                    // Параметры орбиты луны
                    moon.orbitRadius = moonDistance;
                    moon.orbitSpeed = 0.01 + Math.random() * 0.01;
                    moon.orbitAngle = moonAngle;
                    moon.orbitInclination = moonInclination;
                    
                    // Добавляем функцию обновления для луны
                    moon.update = function(delta) {
                        // Вращаем луну вокруг планеты
                        this.orbitAngle += this.orbitSpeed * delta * simulationSpeed;
                        
                        this.position.x = this.orbitRadius * Math.cos(this.orbitAngle);
                        this.position.y = this.orbitRadius * Math.sin(this.orbitInclination);
                        this.position.z = this.orbitRadius * Math.sin(this.orbitAngle);
                        
                        // Вращение луны вокруг своей оси
                        this.rotation.y += 0.01 * delta * simulationSpeed;
                    };
                }
            });
        }
        
        // Обновление физики с учетом скорости симуляции
        function updatePhysics(delta) {
            // Применяем множитель скорости симуляции
            const scaledDelta = delta * simulationSpeed;
            
            // Обновление положения звезды
            updateBodyPosition(star, blackHole, scaledDelta);
            
            // Обновление положения звезды-донора
            updateBodyPosition(donorStar, blackHole, scaledDelta);
            
            // Обновление положения планет
            planets.forEach(planet => {
                // Влияние звезды на планету
                updateOrbit(planet, star, scaledDelta);
                
                // Влияние черной дыры на планету (если планета достаточно близко)
                if (planet.position.distanceTo(blackHole.position) < 100) {
                    updateBodyPosition(planet, blackHole, scaledDelta * 0.5);
                }
            });
            
            // Обновление потока вещества от звезды-донора
            if (donorStar.streamParticles) {
                const positions = donorStar.streamParticles.geometry.attributes.position.array;
                const velocities = donorStar.streamParticles.userData.velocities;
                const lifetimes = donorStar.streamParticles.userData.lifetimes;
                const sizes = donorStar.streamParticles.userData.sizes;
                
                for (let i = 0; i < lifetimes.length; i++) {
                    const i3 = i * 3;
                    
                    // Увеличиваем время жизни частицы
                    lifetimes[i] += 0.005 * scaledDelta;
                    
                    // Обновляем позицию
                    positions[i3] += velocities[i3] * scaledDelta;
                    positions[i3+1] += velocities[i3+1] * scaledDelta;
                    positions[i3+2] += velocities[i3+2] * scaledDelta;
                    
                    // Проверяем расстояние до черной дыры
                    const distToBH = Math.sqrt(
                        Math.pow(positions[i3] - blackHole.position.x, 2) +
                        Math.pow(positions[i3+1] - blackHole.position.y, 2) +
                        Math.pow(positions[i3+2] - blackHole.position.z, 2)
                    );
                    
                    // Если частица достигла черной дыры или срок жизни истек, сбрасываем её
                    if (distToBH < 5 || lifetimes[i] >= 1.0) {
                        updateStreamParticle(i, positions, velocities, lifetimes);
                    } else {
                        // Гравитационное ускорение по направлению к черной дыре (усилено)
                        const dx = blackHole.position.x - positions[i3];
                        const dy = blackHole.position.y - positions[i3+1];
                        const dz = blackHole.position.z - positions[i3+2];
                        
                        const distToBHCubed = Math.pow(distToBH, 3);
                        
                        // Увеличиваем скорость под действием гравитации
                        // Усиливаем эффект для создания более драматичного искривления
                        const accelFactor = scaledDelta * 0.005 * blackHole.mass / distToBHCubed;
                        velocities[i3] += dx * accelFactor;
                        velocities[i3+1] += dy * accelFactor;
                        velocities[i3+2] += dz * accelFactor;
                        
                        // Уменьшаем скорость частиц с течением времени для эффекта растяжения
                        if (distToBH < 15) {
                            const speedFactor = 1.0 + (15 - distToBH) / 15 * 0.5;
                            velocities[i3] *= speedFactor;
                            velocities[i3+1] *= speedFactor;
                            velocities[i3+2] *= speedFactor;
                        }
                    }
                }
            
            // Обновляем размеры частиц (увеличиваем ближе к черной дыре для эффекта растяжения)
            if (donorStar.streamParticles.geometry.attributes.size) {
                const sizeAttr = donorStar.streamParticles.geometry.attributes.size;
                for (let i = 0; i < sizeAttr.array.length; i++) {
                    const i3 = i * 3;
                    const distToBH = Math.sqrt(
                        Math.pow(positions[i3] - blackHole.position.x, 2) +
                        Math.pow(positions[i3+1] - blackHole.position.y, 2) +
                        Math.pow(positions[i3+2] - blackHole.position.z, 2)
                    );
                    
                    if (distToBH < 20) {
                        // Увеличиваем размер ближе к черной дыре для эффекта растяжения
                        sizeAttr.array[i] = sizes[i] * (1.0 + (20 - distToBH) / 20 * 2.0);
                    } else {
                        sizeAttr.array[i] = sizes[i];
                    }
                }
                sizeAttr.needsUpdate = true;
            }

            donorStar.streamParticles.geometry.attributes.position.needsUpdate = true;
    
            // Обновляем путь потока вещества с учетом новых позиций донора и черной дыры
            if (donorStar.streamPath) {
                scene.remove(donorStar.streamPath);
                const newPathGeometry = createStreamPathGeometry(donorStar.position, blackHole.position);
                const pathMaterial = donorStar.streamPath.material;
                const newPath = new THREE.Mesh(newPathGeometry, pathMaterial);
                scene.add(newPath);
                donorStar.streamPath = newPath;
            }

            // Обновление частиц аккреционного диска
            if (showAccretionDisk && accretionDisk.particles) {
                const positions = accretionDisk.particles.geometry.attributes.position.array;
                const velocities = accretionDisk.particles.userData.velocities;
                
                for (let i = 0; i < positions.length; i += 3) {
                    // Обновление позиций частиц с учетом скорости симуляции
                    positions[i] += velocities[i] * scaledDelta * 10;
                    positions[i+2] += velocities[i+2] * scaledDelta * 10;
                    
                    // Расчет расстояния до черной дыры
                    const x = positions[i];
                    const z = positions[i+2];
                    const distance = Math.sqrt(x*x + z*z);
                    
                    // Если частица слишком близко к черной дыре, переместим её обратно на внешний край
                    if (distance < 6) {
                        const angle = Math.atan2(z, x);
                        positions[i] = 30 * Math.cos(angle);
                        positions[i+2] = 30 * Math.sin(angle);
                        
                        // Пересчитаем скорость
                        const radius = 30;
                        const speed = Math.sqrt(G * blackHole.mass / radius) / 1e6;
                        velocities[i] = -speed * Math.sin(angle);
                        velocities[i+2] = speed * Math.cos(angle);
                    }
                    
                    // Добавляем небольшие флуктуации для более реалистичного движения
                    positions[i+1] += (Math.random() - 0.5) * 0.01 * scaledDelta;
                    velocities[i] += (Math.random() - 0.5) * 0.0001 * scaledDelta;
                    velocities[i+2] += (Math.random() - 0.5) * 0.0001 * scaledDelta;
                }
                
                accretionDisk.particles.geometry.attributes.position.needsUpdate = true;
            }
		}
        
        // Обновление орбитального движения
        function updateOrbit(body, center, delta) {
            const angle = body.orbitAngle + body.orbitSpeed * delta;
            body.orbitAngle = angle;
            
            const x = center.position.x + body.orbitRadius * Math.cos(angle);
            const y = body.orbitInclination ? center.position.y + body.orbitRadius * Math.sin(body.orbitInclination) : 0;
            const z = center.position.z + body.orbitRadius * Math.sin(angle);
            
            body.position.set(x, y, z);
            
            // Вращение планеты вокруг своей оси
            if (body.rotationSpeed) {
                body.rotation.y += body.rotationSpeed * delta;
            }
            
            // Обновление спутников
            body.children.forEach(child => {
                if (child.update) {
                    child.update(delta);
                }
            });
        }
        
        // Обновление позиции тела под влиянием гравитации
        function updateBodyPosition(body, gravitySource, delta) {
            const dx = gravitySource.position.x - body.position.x;
            const dy = gravitySource.position.y - body.position.y;
            const dz = gravitySource.position.z - body.position.z;
            
            const distSq = dx*dx + dy*dy + dz*dz;
            const dist = Math.sqrt(distSq);
            
            // Исключаем случаи, когда тела слишком близко
            if (dist < 5) return;
            
            // Сила гравитации F = G*m1*m2/r^2
            const force = G * body.mass * gravitySource.mass / distSq;
            
            // Ускорение a = F/m = G*m2/r^2
            const accel = force / body.mass;
            
            // Компоненты ускорения
            const ax = accel * dx / dist;
            const ay = accel * dy / dist;
            const az = accel * dz / dist;
            
            // Если у тела нет скорости, инициализируем её
            if (!body.velocity) {
                body.velocity = new THREE.Vector3(0, 0, 0);
            }
            
            // Обновление скорости v = v + a*dt
            body.velocity.x += ax * delta / 1e6;
            body.velocity.y += ay * delta / 1e6;
            body.velocity.z += az * delta / 1e6;
            
            // Обновление позиции p = p + v*dt
            body.position.x += body.velocity.x * delta;
            body.position.y += body.velocity.y * delta;
            body.position.z += body.velocity.z * delta;
        }
        
        // Эффект гравитационного линзирования (улучшенный)
		function updateGravitationalLensing() {
			if (!window.lensingEffect) {
				// Создаем более тонкий визуальный эффект для имитации "Интерстеллара"
				// Тонкая сфера искривления света вокруг черной дыры
				const lensGeometry = new THREE.SphereGeometry(15, 32, 32);
				const lensMaterial = new THREE.MeshBasicMaterial({
					color: 0x000000,
					transparent: true,
					opacity: 0.1,
					side: THREE.BackSide
				});
				
				const lensEffect = new THREE.Mesh(lensGeometry, lensMaterial);
				scene.add(lensEffect);
				window.lensingEffect = lensEffect;
				
				// Яркое кольцо искажения (фотонное кольцо)
				const ringGeometry = new THREE.RingGeometry(5, 5.5, 64, 1);
				const ringMaterial = new THREE.MeshBasicMaterial({
					color: 0xffffff,
					transparent: true,
					opacity: 0.9,
					side: THREE.DoubleSide,
					blending: THREE.AdditiveBlending
				});
				
				const photonRing = new THREE.Mesh(ringGeometry, ringMaterial);
				photonRing.rotation.x = Math.PI / 2;
				lensEffect.add(photonRing);
			}
			
			// Обновляем визуальный эффект
			if (showGravitationalLensing) {
				window.lensingEffect.visible = true;
				
				// Небольшое дрожание для эффекта
				window.lensingEffect.rotation.x += 0.0005 * simulationSpeed;
				window.lensingEffect.rotation.y += 0.0003 * simulationSpeed;
			} else {
				if (window.lensingEffect) window.lensingEffect.visible = false;
			}
		}
        function updateCamera(delta) {
            if (cameraMode === 'orbit') {
                // Орбитальная камера вокруг черной дыры
                const time = Date.now() * 0.0003;
                const radius = 120;
                camera.position.x = Math.cos(time) * radius;
                camera.position.z = Math.sin(time) * radius;
                camera.position.y = 30 + Math.sin(time * 0.5) * 20;
                camera.lookAt(0, 0, 0);
            } else if (cameraMode === 'follow') {
                // Камера следует за выбранной планетой или звездой
                let target;
                if (followIndex === planets.length) {
                    target = star;
                } else if (followIndex === planets.length + 1) {
                    target = donorStar;
                } else if (followIndex < planets.length) {
                    target = planets[followIndex];
                } else {
                    // В случае неверного индекса возвращаемся к орбитальному виду
                    cameraMode = 'orbit';
                    return;
                }
                
                // Инициализируем userData для камеры, если необходимо
                if (!camera.userData) camera.userData = {};
                
                // Фиксированное положение камеры относительно объекта - немного позади и сбоку
                // Создаем более стабильную позицию, учитывающую размер объекта
                let offsetDistance = 10;
                if (target === star || target === donorStar) {
                    offsetDistance = target.geometry.parameters.radius * 3;
                } else {
                    offsetDistance = target.geometry.parameters.radius * 8;
                }
                
                // Создаем смещение в локальной системе координат объекта 
                // (позиция камеры будет "следовать" за объектом и его вращением)
                const offsetX = -offsetDistance * 0.7; // позади
                const offsetY = offsetDistance * 0.5;  // немного выше
                const offsetZ = offsetDistance * 0.7;  // сбоку
                
                // Целевая позиция для камеры
                const targetPosition = new THREE.Vector3(
                    target.position.x + offsetX,
                    target.position.y + offsetY,
                    target.position.z + offsetZ
                );
                
                // Плавное перемещение к целевой позиции (интерполяция)
                const lerpFactor = Math.min(0.2, delta * 2); // Ограничиваем скорость смещения
                if (!camera.userData.previousPosition) {
                    camera.userData.previousPosition = targetPosition.clone();
                }
                
                camera.userData.previousPosition.lerp(targetPosition, lerpFactor);
                camera.position.copy(camera.userData.previousPosition);
                
                // Определяем, на что смотрит камера
                let lookAtTarget;
                if (followIndex < planets.length) {
                    // Если следим за планетой, смотрим на саму планету (чтобы она была в кадре)
                    lookAtTarget = target.position.clone();
                } else {
                    // Для звезд смотрим на черную дыру
                    lookAtTarget = blackHole.position.clone();
                }
                
                // Плавный поворот камеры к целевой точке
                if (!camera.userData.lookAtTarget) {
                    camera.userData.lookAtTarget = lookAtTarget.clone();
                } else {
                    camera.userData.lookAtTarget.lerp(lookAtTarget, lerpFactor);
                }
                
                camera.lookAt(camera.userData.lookAtTarget);
            } else if (cameraMode === 'blackhole') {
                // Вид от черной дыры, смотрим на звезду с небольшими вариациями для живости
                const time = Date.now() * 0.0001;
                const posOffset = new THREE.Vector3(
                    Math.sin(time * 0.5) * 0.5,
                    3 + Math.sin(time * 0.3) * 0.3,
                    Math.cos(time * 0.5) * 0.5
                );
                
                camera.position.copy(blackHole.position).add(posOffset);
                camera.lookAt(star.position);
            } else if (cameraMode === 'dramatic') {
                // Драматический вид сбоку от системы с плавным движением
                const time = Date.now() * 0.0001;
                const radius = 150;
                camera.position.set(
                    Math.cos(time) * radius,
                    10 + Math.sin(time * 0.5) * 8, // Более плавная вертикальная амплитуда
                    Math.sin(time) * radius / 2
                );
                
                // Смотрим на область между черной дырой и звездами с плавными изменениями
                const lookTarget = new THREE.Vector3(
                    (blackHole.position.x + star.position.x) / 3 + Math.sin(time * 0.7) * 5,
                    Math.sin(time * 0.3) * 3,
                    (blackHole.position.z + star.position.z) / 3 + Math.cos(time * 0.7) * 5
                );
                camera.lookAt(lookTarget);
            }
            
            // Добавляем небольшую тряску камеры при близости к черной дыре
            // но делаем её более тонкой и зависящей от скорости симуляции
            if (camera.position.distanceTo(blackHole.position) < 30) {
                const shakeIntensity = (30 - camera.position.distanceTo(blackHole.position)) / 30 * 0.05 * simulationSpeed;
                camera.position.x += (Math.random() - 0.5) * shakeIntensity;
                camera.position.y += (Math.random() - 0.5) * shakeIntensity;
                camera.position.z += (Math.random() - 0.5) * shakeIntensity;
            }
        }
        // Обработчик изменения размеров окна
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Переключение режима камеры
        function toggleCameraMode() {
            if (cameraMode === 'orbit') {
                cameraMode = 'follow';
                followIndex = 0;
            } else if (cameraMode === 'follow') {
                followIndex = (followIndex + 1) % (planets.length + 2); // +2 для звезды и звезды-донора
                if (followIndex === 0) {
                    cameraMode = 'blackhole';
                }
            } else if (cameraMode === 'blackhole') {
                cameraMode = 'dramatic';
            } else {
                cameraMode = 'orbit';
            }
            
            // Обновляем информацию в UI
            document.getElementById('info').textContent = getCameraInfo();
        }
        
        // Получение информации о текущем режиме камеры
        function getCameraInfo() {
            if (cameraMode === 'orbit') {
                return "Орбитальная камера - обзор всей системы";
            } else if (cameraMode === 'follow') {
                if (followIndex === planets.length) {
                    return "Камера следует за главной звездой";
                } else if (followIndex === planets.length + 1) {
                    return "Камера следует за звездой-донором";
                } else {
                    return `Камера следует за планетой ${followIndex + 1}`;
                }
            } else if (cameraMode === 'blackhole') {
                return "Вид от черной дыры";
            } else {
                return "Драматический обзор системы";
            }
        }
        
        // Переключение видимости аккреционного диска
        function toggleAccretionDisk() {
            showAccretionDisk = !showAccretionDisk;
            accretionDisk.visible = showAccretionDisk;
            if (accretionDisk.particles) {
                accretionDisk.particles.visible = showAccretionDisk;
            }
            
            // Обновляем текст на кнопке для лучшего UX
            document.getElementById('toggleAccretionDisk').textContent = 
                showAccretionDisk ? "Выключить аккреционный диск" : "Включить аккреционный диск";
        }
        
        function toggleGravitationalLensing() {
            showGravitationalLensing = !showGravitationalLensing;
            
            // Показываем или скрываем джеты в зависимости от настройки линзирования
            if (blackHole && blackHole.jets) {
                blackHole.jets.forEach(jet => {
                    jet.visible = !showGravitationalLensing;
                });
            }
            
            updateGravitationalLensing();
            
            // Обновляем текст на кнопке для лучшего UX
            document.getElementById('toggleGravitationalLensing').textContent = 
                showGravitationalLensing ? "Выключить гравитационное линзирование" : "Включить гравитационное линзирование";
        }
        // Создание событий для добавления драматизма в симуляцию
        function scheduleEvents() {
            // Планируем случайные события
            setInterval(() => {
                // Выбираем случайное событие с определенной вероятностью
                const eventType = Math.random();
                
                if (eventType < 0.3 && simulationSpeed > 0.5) {
                    // Усиление джета
                    createJetBurst();
                } else if (eventType < 0.6) {
                    // Выброс вещества из аккреционного диска
                    createDiskEjection();
                } else {
                    // Вспышка на звезде
                    createStellarFlare();
                }
            }, 10000); // Событие каждые ~10 секунд
        }
        
        // Создание вспышки на звезде
        function createStellarFlare() {
            if (!star) return;
            
            // Создаем вспышку как яркий свет
            const flareColor = new THREE.Color(0xffffaa);
            const flareLight = new THREE.PointLight(flareColor, 2, 100);
            star.add(flareLight);
            
            // Временно увеличиваем размер короны
            if (star.children[1]) {
                star.children[1].scale.set(1.5, 1.5, 1.5);
                star.children[1].material.opacity = 0.7;
            }
            
            // Убираем эффекты через некоторое время
            setTimeout(() => {
                star.remove(flareLight);
                if (star.children[1]) {
                    star.children[1].scale.set(1, 1, 1);
                    star.children[1].material.opacity = 0.3;
                }
            }, 1000);
        }
		
		// 8. Исправление обновления частиц аккреционного диска
		function updateAccretionDiskParticles(delta) {
			if (!showAccretionDisk || !accretionDisk.particles) return;
			
			const particles = accretionDisk.particles;
			const positions = particles.geometry.attributes.position.array;
			const velocities = particles.userData.velocities;
			const lifetimes = particles.userData.lifetimes;
			const originalPositions = particles.userData.originalPositions;
			
			for (let i = 0; i < positions.length / 3; i++) {
				const i3 = i * 3;
				
				// Обновляем время жизни частицы
				lifetimes[i] += 0.001 * delta * simulationSpeed;
				if (lifetimes[i] > 1) lifetimes[i] = 0;
				
				// Обновление позиций частиц с учетом скорости симуляции
				positions[i3] += velocities[i3] * delta * simulationSpeed * 5;
				positions[i3+1] += velocities[i3+1] * delta * simulationSpeed * 5;
				positions[i3+2] += velocities[i3+2] * delta * simulationSpeed * 5;
				
				// Расчет расстояния до черной дыры
				const x = positions[i3];
				const y = positions[i3+1];
				const z = positions[i3+2];
				const distance = Math.sqrt(x*x + z*z); // Только для плоскости XZ
				
				// Если частица слишком близко к черной дыре или слишком далеко, переместим её обратно
				if (distance < 6 || distance > 36 || lifetimes[i] >= 0.99 || Math.abs(y) > 1.5) {
					// Создаем новую частицу на основе исходного распределения
					const idx = Math.floor(Math.random() * originalPositions.length / 3) * 3;
					const angle = Math.random() * Math.PI * 2;
					const radius = 6 + Math.pow(Math.random(), 0.8) * 30;
					
					// Немного варьируем позицию
					positions[i3] = radius * Math.cos(angle);
					positions[i3+1] = (Math.random() - 0.5) * 0.5 * (1 - Math.pow(radius / 36, 1.5));
					positions[i3+2] = radius * Math.sin(angle);
					
					// Пересчитываем скорость
					const speed = Math.sqrt(G * blackHole.mass / radius) / 9e5;
					velocities[i3] = -speed * Math.sin(angle) * (1 + (Math.random() - 0.5) * 0.1);
					velocities[i3+1] = (Math.random() - 0.5) * 0.001;
					velocities[i3+2] = speed * Math.cos(angle) * (1 + (Math.random() - 0.5) * 0.1);
					
					// Сбрасываем время жизни
					lifetimes[i] = Math.random() * 0.2; // Небольшой разброс начального времени
				}
				
				// Добавляем небольшие флуктуации для более реалистичного движения
				// Но делаем их более тонкими
				positions[i3+1] += (Math.random() - 0.5) * 0.003 * delta * simulationSpeed;
				velocities[i3] += (Math.random() - 0.5) * 0.00005 * delta * simulationSpeed;
				velocities[i3+2] += (Math.random() - 0.5) * 0.00005 * delta * simulationSpeed;
			}
			
			particles.geometry.attributes.position.needsUpdate = true;
		}

        function createDiskFlash() {
            if (!accretionDisk) return;
            
            // Случайная позиция на диске
            const angle = Math.random() * Math.PI * 2;
            const radius = 8 + Math.random() * 30;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            
            // Создаем вспышку как световой источник
            const flashLight = new THREE.PointLight(0xffffcc, 2 + Math.random() * 3, 10 + Math.random() * 10);
            flashLight.position.set(x, Math.random() * 0.3, z);
            scene.add(flashLight);
            
            // Создаем визуализацию вспышки
            const flashGeometry = new THREE.SphereGeometry(0.5 + Math.random() * 0.5, 16, 16);
            const flashMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffee,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            const flash = new THREE.Mesh(flashGeometry, flashMaterial);
            flash.position.copy(flashLight.position);
            scene.add(flash);
            
            // Длительность вспышки
            const duration = 300 + Math.random() * 400;
            
            // Удаляем вспышку после окончания
            setTimeout(() => {
                scene.remove(flashLight);
                scene.remove(flash);
            }, duration);
        }

        function updateSimulationEffects(delta) {
            // Обновление эффектов аккреционного диска
            if (showAccretionDisk && accretionDisk) {
                // Пульсация яркости аккреционного диска для большей реалистичности
                const time = Date.now() * 0.0005;
                const pulseFactor = 1 + Math.sin(time) * 0.1;
                
                // Найдем световой источник в аккреционном диске
                accretionDisk.children.forEach(child => {
                    if (child instanceof THREE.PointLight) {
                        child.intensity = 2 + Math.sin(time * 1.5) * 0.5;
                    }
                });
                
                // Случайные вспышки на аккреционном диске
                if (Math.random() < 0.02 * delta * simulationSpeed) {
                    createDiskFlash();
                }
            }
            
            // Обновление потока вещества от звезды-донора
            if (donorStar && donorStar.streamPath) {
                const time = Date.now() * 0.0003;
                // Пульсация яркости потока вещества
                const opacity = 0.2 + Math.sin(time) * 0.05;
                donorStar.streamPath.material.opacity = opacity;
            }
        }
        
        // Создание выброса вещества из аккреционного диска
        function createDiskEjection() {
            if (!showAccretionDisk || !accretionDisk) return;
            
            // Создаем геометрию для выброса
            const ejectionGeometry = new THREE.BufferGeometry();
            const ejectionMaterial = new THREE.PointsMaterial({
                color: 0xffaa66,
                size: 0.8,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            const particlesCount = 500;
            const positions = new Float32Array(particlesCount * 3);
            const velocities = [];
            
            // Выбираем случайный угол для выброса
            const ejectionAngle = Math.random() * Math.PI * 2;
            const ejectionRadius = 10 + Math.random() * 15;
            
            // Инициализируем частицы
            for (let i = 0; i < particlesCount; i++) {
                const i3 = i * 3;
                const spreadAngle = ejectionAngle + (Math.random() - 0.5) * 0.5;
                const distance = ejectionRadius + Math.random() * 2;
                
                positions[i3] = Math.cos(spreadAngle) * distance;
                positions[i3+1] = (Math.random() - 0.5) * 2;
                positions[i3+2] = Math.sin(spreadAngle) * distance;
                
                // Скорость - в направлении от центра
                const speed = 0.1 + Math.random() * 0.2;
                velocities.push(
                    Math.cos(spreadAngle) * speed,
                    (Math.random() - 0.5) * 0.1,
                    Math.sin(spreadAngle) * speed
                );
            }
            
            ejectionGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const ejection = new THREE.Points(ejectionGeometry, ejectionMaterial);
            ejection.userData.velocities = velocities;
            ejection.userData.lifetime = 0;
            ejection.userData.maxLifetime = 3; // Время жизни в секундах
            
            scene.add(ejection);
            
            // Сохраняем для обновления
            if (!window.ejections) window.ejections = [];
            window.ejections.push(ejection);
        }
        
        // Создание усиленного выброса джета
        function createJetBurst() {
            if (!blackHole || blackHole.children.length < 4) return;
            
            // Выбираем случайный джет (верхний или нижний)
            const jetIndex = Math.random() < 0.5 ? 2 : 3;
            const jet = blackHole.children[jetIndex];
            
            if (jet) {
                // Временно увеличиваем яркость и размер
                jet.material.opacity = 1.0;
                jet.scale.set(1.5, 1.2, 1.5);
                
                // Добавляем дополнительные частицы в джет
                if (jet.particles) {
                    const positions = jet.particles.geometry.attributes.position.array;
                    const velocities = jet.particles.userData.velocities;
                    
                    for (let i = 0; i < velocities.length; i += 3) {
                        // Увеличиваем скорость
                        velocities[i] *= 2;
                        velocities[i+1] *= 2;
                        velocities[i+2] *= 2;
                    }
                }
                
                // Возвращаем в нормальное состояние через некоторое время
                setTimeout(() => {
                    if (jet) {
                        jet.material.opacity = 0.7;
                        jet.scale.set(1, 1, 1);
                        
                        if (jet.particles) {
                            const velocities = jet.particles.userData.velocities;
                            
                            for (let i = 0; i < velocities.length; i += 3) {
                                // Возвращаем скорость к нормальной
                                velocities[i] *= 0.5;
                                velocities[i+1] *= 0.5;
                                velocities[i+2] *= 0.5;
                            }
                        }
                    }
                }, 2000);
            }
        }
        
        // Анимация
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            // Обновление физики
            updatePhysics(delta);
            
            // Обновление эффектов
            updateGravitationalLensing();
            updateJetParticles(delta);
            // // Обновление джетов черной дыры
            // if (blackHole && blackHole.children && blackHole.children.length >= 4) {
            //     updateJetParticles(blackHole.children[2], delta);
            //     updateJetParticles(blackHole.children[3], delta);
            // }
            
            // Обновление выбросов из аккреционного диска
            if (window.ejections && window.ejections.length > 0) {
                updateEjections(delta);
            }
            
            // Обновление камеры
            updateCamera(delta);
            
            // Вращение аккреционного диска
            if (showAccretionDisk && accretionDisk && accretionDisk.children && accretionDisk.children.length > 0) {
                accretionDisk.children.forEach((ring, index) => {
                    // Внутренние кольца вращаются быстрее
                    const rotationSpeed = 0.002 * simulationSpeed / (index + 1);
                    ring.rotation.z += rotationSpeed;
                });
            }
            
            // Добавляем пульсацию короны звезды
            if (star.children[1]) { // Корона - это второй ребенок звезды
                const time = Date.now() * 0.001;
                const pulseFactor = 1 + Math.sin(time * 2) * 0.1;
                star.children[1].scale.set(pulseFactor, pulseFactor, pulseFactor);
            }
            
            // Добавляем пульсацию черной дыры
            if (showGravitationalLensing && Math.random() < 0.05 * simulationSpeed) {
                const pulse = new THREE.Mesh(
                    new THREE.SphereGeometry(6, 32, 32),
                    new THREE.MeshBasicMaterial({
                        color: 0x0066ff,
                        transparent: true,
                        opacity: 0.5
                    })
                );
                pulse.position.copy(blackHole.position);
                pulse.userData.expansionRate = 0.5 + Math.random() * 0.5;
                pulse.userData.opacity = 0.5;
                scene.add(pulse);
                
                // Добавляем пульс в список для анимации
                if (!window.pulses) window.pulses = [];
                window.pulses.push(pulse);
            }
            
            // Анимируем существующие пульсы
            if (window.pulses && window.pulses.length > 0) {
                for (let i = window.pulses.length - 1; i >= 0; i--) {
                    const pulse = window.pulses[i];
                    pulse.scale.multiplyScalar(1 + pulse.userData.expansionRate * 0.05 * simulationSpeed);
                    pulse.material.opacity -= 0.02 * simulationSpeed;
                    
                    if (pulse.material.opacity <= 0) {
                        scene.remove(pulse);
                        window.pulses.splice(i, 1);
                    }
                }
            }
			
			    // Обновляем сверхгигант, если он существует
			if (window.supergiant) {
				window.supergiant.update(delta);
			}
            
			if (showAccretionDisk && accretionDisk.particles) {
				updateAccretionDiskParticles(delta);
			}
			updateSimulationEffects(delta);
            renderer.render(scene, camera);
        }
        
        // Обновление выбросов из аккреционного диска
        function updateEjections(delta) {
            for (let i = window.ejections.length - 1; i >= 0; i--) {
                const ejection = window.ejections[i];
                ejection.userData.lifetime += delta * simulationSpeed;
                
                // Перемещаем частицы
                const positions = ejection.geometry.attributes.position.array;
                const velocities = ejection.userData.velocities;
                
                for (let j = 0; j < positions.length; j += 3) {
                    positions[j] += velocities[j/3*3] * delta * simulationSpeed;
                    positions[j+1] += velocities[j/3*3+1] * delta * simulationSpeed;
                    positions[j+2] += velocities[j/3*3+2] * delta * simulationSpeed;
                }
                
                ejection.geometry.attributes.position.needsUpdate = true;
                
                // Уменьшаем яркость со временем
                ejection.material.opacity = Math.max(0, 0.8 - (ejection.userData.lifetime / ejection.userData.maxLifetime) * 0.8);
                
                // Удаляем, если время жизни истекло
                if (ejection.userData.lifetime >= ejection.userData.maxLifetime) {
                    scene.remove(ejection);
                    window.ejections.splice(i, 1);
                }
            }
        }
        
        // Запускаем инициализацию при загрузке страницы
        document.addEventListener('DOMContentLoaded', () => {
            init();
            scheduleEvents(); // Запускаем планировщик случайных событий
        });
    </script>
</body>
</html>
